{"data":{"site":{"siteMetadata":{"title":"Pil Developer Diary","author":"LEE PIL JU","labels":[{"tag":"algorithm","tech":"Algorithm","name":"DiCode","size":20,"color":"deepskyblue"},{"tag":"react","tech":"React","name":"DiReact","size":20,"color":"deepskyblue"},{"tag":"nodejs","tech":"Node.js","name":"DiNodejsSmall","size":20,"color":"lightgreen"},{"tag":"git","tech":"Git","name":"DiGitMerge","size":20,"color":"white"},{"tag":"javascript","tech":"JavaScript","name":"DiJsBadge","size":20,"color":"yellow"},{"tag":"css","tech":"CSS","name":"DiCss3Full","size":20,"color":"teal"},{"tag":"python","tech":"Python","name":"DiPython","size":20,"color":"deepskyblue"},{"tag":"ruby","tech":"Ruby","name":"DiRuby","size":20,"color":"crimson"},{"tag":"java","tech":"Java","name":"FaJava","size":20,"color":"wheat"},{"tag":"angular","tech":"Angular","name":"DiAngularSimple","size":20,"color":"red"},{"tag":"html","tech":"HTML","name":"FaHtml5","size":20,"color":"darkorange"},{"tag":"php","tech":"php","name":"DiPhp","size":20,"color":"violet"},{"tag":"mongodb","tech":"MongoDB","name":"DiMongodb","size":20,"color":"green"},{"tag":"vscode","tech":"VS Code","name":"DiVisualstudio","size":20,"color":"deepskyblue"}]}},"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"excerpt":"최초 실행git-flow 설치 : apt-get install git-flownode -프로젝트 복사 : git clonebranch 설정 세팅: git flow init (master 입력 후, 끝날 때까지 엔터)브랜치 연결 : git branch -u origin/develop모든 파일이 mofified 일때 : git checkout…","html":"<ul>\n<li>\n<p>최초 실행</p>\n<ul>\n<li>git-flow 설치 : apt-get install git-flownode -</li>\n<li>프로젝트 복사 : git clone</li>\n<li>branch 설정 세팅: git flow init (master 입력 후, 끝날 때까지 엔터)</li>\n<li>브랜치 연결 : git branch -u origin/develop</li>\n<li>모든 파일이 mofified 일때 : git checkout -- .</li>\n</ul>\n</li>\n<li>\n<p>feature </p>\n<ul>\n<li>\n<p>가) 최신 버전 풀</p>\n<ol>\n<li>git checkout develop</li>\n<li>git pull origin develop</li>\n</ol>\n</li>\n<li>\n<p>나) 브랜치 생성 - 테스크 작업 시작할때</p>\n<ol>\n<li>git flow feature start -F [브런치이름]</li>\n</ol>\n</li>\n<li>\n<p>다) 브랜치 이동 - 작업중 다른 테스크로 이동</p>\n<ol>\n<li>브런치 아이디 확인 : git branch</li>\n<li>git checkout [브런치이름]</li>\n</ol>\n</li>\n<li>\n<p>라) 작업 완료시 - publish</p>\n<ol>\n<li>git flow feature publish [브런치이름]</li>\n</ol>\n</li>\n<li>\n<p>마) 로컬 브랜치 삭제</p>\n<ol>\n<li>git branch feature/[브런치이름] -D</li>\n</ol>\n</li>\n<li>\n<p>바) 오리진에 있는 다른 브랜치를 딸때\ngit checkout -t origin/[브런치이름] : 원격 저장소의 브랜치를 가져온다.<br>\n에러가 날 경우, git fetch 를 실행하여 원격 저장소의 브랜치 리스트를 업데이트 한다.  </p>\n</li>\n<li>\n<p>사) 로컬 브랜치에있는 브랜치를 복사 할때<br>\n복사할 대상 브랜치로 checkout 후<br>\ngit checkout -b [브런치이름]</p>\n</li>\n<li>\n<p>아) 작업 완료 후 - push\ngit push origin [브런치이름]</p>\n</li>\n</ul>\n</li>\n<li>\n<p>릴리즈</p>\n<ul>\n<li>\n<p>가) 로컬에 릴리즈 브랜치와 같은이름의 브랜치 생성 및 이동</p>\n<ol>\n<li>git branch [릴리즈 브랜치 이름]</li>\n<li>git checkout[릴리즈 브랜치 이름]</li>\n</ol>\n</li>\n<li>\n<p>나) 원격에서 로컬로 pull</p>\n<ol>\n<li>git pull origin [릴리즈 브랜치 이름]</li>\n</ol>\n</li>\n<li>\n<p>다) 작업 완료후 커밋 -> 푸시</p>\n<ol>\n<li>git commit -a -m “[comment]”</li>\n<li>git push origin [릴리즈 브랜치 이름]</li>\n</ol>\n</li>\n<li>\n<p>핫픽스</p>\n<ul>\n<li>\n<p>가) 마스터 브랜치로 이동</p>\n<ol>\n<li>git checkout master</li>\n</ol>\n</li>\n<li>\n<p>가) 브랜치 시작</p>\n<ol>\n<li>git flow hotfix start -F [브런치이름]</li>\n</ol>\n</li>\n<li>\n<p>나) 수정하고 바로 배포</p>\n<ol>\n<li>git flow hotfix finish -Fp [브런치이름]</li>\n</ol>\n</li>\n<li>\n<p>다) 태그, 코멘트 메세지 입력</p>\n<ol>\n<li>입력후 :wq</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>에러</p>\n<ul>\n<li>\n<p>가) branch ‘develop’ may be fast-forwarded.</p>\n<ul>\n<li>git checkout develop &#x26;&#x26; git pull origin</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>\n<p>commit 취소</p>\n<ul>\n<li>git reset HEAD^ : 최종 커밋을 취소. 워킹트리는 보존됨. (커밋은 했으나 push하지 않은 경우 유용)</li>\n<li>git reset HEAD~2 : 마지막 2개의 커밋을 취소. 워킹트리는 보존됨.</li>\n<li>git reset --hard HEAD~2 : 마지막 2개의 커밋을 취소. index 및 워킹트리 모두 원복됨.</li>\n<li>git reset --hard ORIG_HEAD : 머지한 것을 이미 커밋했을 때,  그 커밋을 취소. (잘못된 머지를 이미 커밋한 경우 유용)</li>\n<li>git revert HEAD : HEAD에서 변경한 내역을 취소하는 새로운 커밋 발행(undo commit). (커밋을 이미 push 해버린 경우 유용)</li>\n</ul>\n</li>\n</ul>","id":"cc22b3d1-6656-594c-92bc-c62333ea1cc4","frontmatter":{"title":"Git 사용 명령어 정리","date":"July 08, 2019","tags":["git"]},"fields":{"slug":"/Github/myDocGit/"}}},{"node":{"excerpt":"재귀란?사전적 정의: 재귀(recursion…","html":"<h3>재귀란?</h3>\n<p>사전적 정의: 재귀(recursion)은 어떠한 것을 정의할 때 자기 자신을 참조하는 것을 뜻한다. <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%AC%EA%B7%80\">위키피디아</a></p>\n<p>알고리즘을 공부할 때, 빠질 수 없는 부분이 재귀함수라고 생각한다.\n알고리즘이 재귀함수를 사용하여 문제를 푸는 경우를 종종 볼 수 있었다.\n지금까지 재귀함수란 특정 함수 내에서 동일 함수를 반복하여 호출하는 것이라고만 알고 있었다.</p>\n<p>하지만 직접 재귀함수를 호출을 하라고 하면 못하는 경우가 많이 있었다.\n따라서 오늘은 재귀함수를 사용해보도록 하자.</p>\n<p>먼저 재귀 함수를 공부하기 위해 간단한 3가지의 문제를 구현해보도록 하자.  </p>\n<p><strong>1. N펙토리얼을 구하라</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function factorial(n) {\n    if (n === 1) {\n        return n;\n    }\n    return n * factorial(n - 1);\n}\nconsole.log(factorial(3));</code></pre></div>\n<p>위와 같이, 재귀함수를 사용할 경우, 반드시 종료조건을 설정해줘야 한다.\n만약 종료조건을 설정해 주지 않는다면 무한루프에 빠져 함수가 영원히 종료되지 않는다.  </p>\n<p><strong>2. X의 N제곱 수를 구하라</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function pow(n, x) {\n    if (n === 1) {\n        return x;\n    }\n    return pow(n-1, x) * x; \n}\nconsole.log(pow(3, 3));</code></pre></div>\n<p>문제1 과 같이 쉽게 구현 할 수 있었다.  </p>\n<p><strong>3. N번째 피보나치수를 구하라</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function fibonacci(n, sum = 1) {\n    if (n &lt;= 2) return sum;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\nconsole.log(fibonacci(1));\nconsole.log(fibonacci(2));\nconsole.log(fibonacci(3));\nconsole.log(fibonacci(4));\nconsole.log(fibonacci(5));</code></pre></div>\n<p>피보나치 수의 경우, <code class=\"language-text\">N번째 수 = N-1번째수 + N-2번째 수</code> 이다.\n위와 같이 코드를 작성하였을 경우, 정상적으로 출력되는 것을 볼 수 있다.\n하지만 n=50 정도만 되어도 상당히 느리게 동작하는 것을 볼 수 있다.</p>\n<p>따라서 위의 코드를 다음과 같이 변환하여 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const list = [0, 1, 1]; // n번째 수를 저장하는 배열\nfunction fibonacci(n) {\n    if (n &lt;= 2) return;\n    fibonacci(n-1);\n    list.push(list[n - 1] + list[n - 2]; ); // n번째 수를 계산하여 list의 n번째에 넣도록 한다.\n}\n\nconst n = 30;\nfibonacci(n);\nconsole.log(list[n]); // 리스트에 들어있는 n번째 수를 출력하도록 한다.</code></pre></div>\n<p>위와 같이 재귀함수에서 다른 동일 함수를 한 번만 호출하도록 변경하였을 경우, 더 빠른 속도로 결괏값을 낼 수 있는 경우를 볼 수 있다. </p>\n<p><strong>정리</strong>: 재귀함수를 사용하는 방법은 여러 가지의 방법이 있지만, 잘못 사용할 경우 프로그램의 성능에 크게 타격을 주게 된다. 재귀함수를 사용할때 최적의 속도록 활용할 수 있는 방법이 중요하다.</p>","id":"88e21698-0a1f-5183-9d16-562006f03e86","frontmatter":{"title":"Recursion(재귀)","date":"July 08, 2019","tags":["algorithm","javascript"]},"fields":{"slug":"/Algorithm/recursion/"}}},{"node":{"excerpt":"…","html":"<p>출처: <a href=\"https://programmers.co.kr/learn/courses/30/lessons/43104?language=javascript\">프로그래머스 타일 장식물</a></p>\n<p>문제의 종류는 동적 계획법이다.<br>\n하지만 이제 알고리즘을 시작하는 단계라 동적계획법을 사용하는 방법을 모르고 있다.<br>\n따라서 내가 생각한 방식대로 문제를 풀어보도록 한다.<br>\n먼저 <a href=\"https://devpil.github.io/Algorithm/recursion/\">이전 게시물</a>에 피보나치수열에 대하여 포스팅한 적이 있다. 이를 통하여 문제를 풀어보도록 하자.  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function fibonacci(N, list) {\n    if (N &lt;= 2) return;\n    fibonacci(N - 1, list);\n    list.push(list[N-1] + list[N - 2]);\n}\n\nfunction solution(N) {\n    const list = [0, 1, 1];\n    fibonacci(N, list);\n    return (list[N] + list[N-1]) * 2 + (list[N-1] + list[N-2]) * 2;\n}</code></pre></div>\n<p>위와같이 피보나치수열을 만든 후, 둘레를 구하기 때문에 <code class=\"language-text\">가로(N번째 + N-1번째) * 2 + 세로(N-1번째 + N-2번째) *2 = 둘레의 길이</code>가 된다.\n따라서 위와같이 값을 리턴해주도록 한다.</p>\n<p>문제를 풀다보니, 피보나치수열을 꼭 재귀함수를 이용해 풀 이유가 없다고 생각이 들었다.\n따라서 다음과같이 문제를 바꿔서 풀어보도록 하자.\n재귀함수 부분을 단순 반복문으로 바꿔보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function solution(N) {\n    const list = [0, 1, 1];\n    for(let i = 3; i &lt;= N; i++) {\n        list.push(list[i - 1] + list[i - 2]);\n    }\n    return (list[N] + list[N-1]) * 2 + (list[N-1] + list[N-2]) * 2;\n}</code></pre></div>\n<p>훨씬 간결한 코드가 완성되었다.\n<strong>정리</strong>: 알고리즘을 푸는 방식은 다양하다. 조금 더 깔끔하고, 보기좋은 코드로 만드는 방식은 문제를 많이풀어보는것 뿐인것 같다.</p>","id":"94c75232-960d-5f37-896a-662abfe959f8","frontmatter":{"title":"[프로그래머스 - 동적계획법] 타일 장식물","date":"July 08, 2019","tags":["algorithm","javascript"]},"fields":{"slug":"/Algorithm/programmers_30_4104/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}