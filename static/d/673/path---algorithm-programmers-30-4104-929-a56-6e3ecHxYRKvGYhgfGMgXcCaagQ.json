{"data":{"site":{"siteMetadata":{"url":"https://developer-diary.netlify.com","title":"Pil Developer Diary","labels":[{"tag":"algorithm","tech":"Algorithm","name":"DiCode","size":20,"color":"deepskyblue"},{"tag":"react","tech":"React","name":"DiReact","size":20,"color":"deepskyblue"},{"tag":"nodejs","tech":"Node.js","name":"DiNodejsSmall","size":20,"color":"lightgreen"},{"tag":"git","tech":"Git","name":"DiGitMerge","size":20,"color":"white"},{"tag":"javascript","tech":"JavaScript","name":"DiJsBadge","size":20,"color":"yellow"},{"tag":"css","tech":"CSS","name":"DiCss3Full","size":20,"color":"teal"},{"tag":"python","tech":"Python","name":"DiPython","size":20,"color":"deepskyblue"},{"tag":"ruby","tech":"Ruby","name":"DiRuby","size":20,"color":"crimson"},{"tag":"java","tech":"Java","name":"FaJava","size":20,"color":"wheat"},{"tag":"angular","tech":"Angular","name":"DiAngularSimple","size":20,"color":"red"},{"tag":"html","tech":"HTML","name":"FaHtml5","size":20,"color":"darkorange"},{"tag":"php","tech":"php","name":"DiPhp","size":20,"color":"violet"},{"tag":"mongodb","tech":"MongoDB","name":"DiMongodb","size":20,"color":"green"},{"tag":"vscode","tech":"VS Code","name":"DiVisualstudio","size":20,"color":"deepskyblue"}]}},"markdownRemark":{"html":"<p><br>\n출처: <a href=\"https://programmers.co.kr/learn/courses/30/lessons/43104?language=javascript\">프로그래머스 타일 장식물</a></p>\n<p>문제의 종류는 동적 계획법이다.<br>\n하지만 이제 알고리즘을 시작하는 단계라 동적 계획법을 사용하는 방법을 모르고 있다.<br>\n따라서 내가 생각한 방식대로 문제를 풀어보도록 한다.<br>\n먼저 <a href=\"https://devpil.github.io/Algorithm/recursion/\">이전 게시물</a>에 피보나치 수열에 대하여 포스팅한 적이 있다. 이를 통하여 문제를 풀어보도록 하자.  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function fibonacci(N, list) {\n    if (N &lt;= 2) return;\n    fibonacci(N - 1, list);\n    list.push(list[N-1] + list[N - 2]);\n}\n\nfunction solution(N) {\n    const list = [0, 1, 1];\n    fibonacci(N, list);\n    return (list[N] + list[N-1]) * 2+ (list[N-1] + list[N-2]) * 2 ;\n}</code></pre></div>\n<p>먼저 직사각형 둘레의 길이는 <code class=\"language-text\">(가로 + 세로) * 2</code>이다.<br>\n위의 공식을 피보나치 수열에 적용하게 된다면<code class=\"language-text\">(가로(N번째 + N-1번째) + 세로(N-1번째 + N-2번째))*2</code>가 된다.<br>\n따라서 위와 같이 값을 리턴해주도록 한다.  </p>\n<p>문제를 풀다 보니, 피보나치 수열을 꼭 재귀함수를 이용해 풀 이유가 없다고 생각이 들었다.<br>\n따라서 다음과 같이 문제를 바꿔서 풀어보도록 하자.<br>\n재귀함수 부분을 단순 반복문으로 바꿔보았다.  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function solution(N) {\n    const list = [0, 1, 1];\n    for(let i = 3; i &lt;= N; i++) {\n        list.push(list[i - 1] + list[i - 2]);\n    }\n    return (list[N] + list[N-1]) * 2 + (list[N-1] + list[N-2]) * 2;\n}</code></pre></div>\n<p>훨씬 간결한 코드가 완성되었다.</p>\n<p><strong>정리</strong>: <strong>return</strong>값을 <strong>(list[N] + list[N-1] + list[N-1] + list[N-2]) * 2</strong>로 할경우, 효율성부분에서 실패하는 것을 볼 수 있었다. 하지만 <strong>(list[N] + list[N-1]) * 2 + list[N-1] + list[N-2])*2</strong>로 할경우 통과하는 것을 볼 수 있었다. 각각 연산을 한 후 더해주는 것 보다. 다 더한 후 한 번에 곱셈연산을 할 경우, 시간복잡도가 더 증가하는 것 같았다. 시간복잡도를 확인하는 부분이 아직 익숙하지가 않다. 조금 더 연습이 필요하다.</p>","frontmatter":{"title":"[프로그래머스 - 동적 계획법] 타일 장식물","date":"July 09, 2019","tags":["algorithm","javascript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Algorithm/programmers_30_4104/"}}